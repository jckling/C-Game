# 目录
* [5-1 求斜边](#5-1-求斜边)
* [5-2 倍数判断](#5-2-倍数判断)
* [5-3 停车时间](#5-3-停车时间)
* [5-4 计算组合数](#5-4-计算组合数)
* [5-5 求最小公倍数](#5-5-求最小公倍数)
* [5-6 最大公约数-1](#5-6-最大公约数-1)
* [5-7 求e的x幂](#5-7-求e的x幂)
* [5-8 求最大公约数-2](#5-8-求最大公约数-2)
* [5-9 哥德巴赫猜想](#5-9-哥德巴赫猜想)
* [5-10 可逆素数对](#5-10-可逆素数对)

<br>

## 5-1 求斜边
**Description：**<br>
定义一个名为hypotenuse的函数，它的功能是：当给出直角三角形的两条直角边时，计算直角三角形斜边的长度。这个函数将输入两个双精度型的实参，然后返回一个双精度型的结果作为直角三角形斜边的长度，小数点后保留1位。请用这个函数编写程序，分别输入三个三角形的便，测试一下三角形的斜边长度。

<br>**Sample Input：**<br>
```
3,4
3.5,6
67,23
```

<br>**Sample Output：**<br>
```
Hypotenuse:5.0
Hypotenuse:6.9
Hypotenuse:70.8
```

<br>

## 5-2 倍数判断
**Description：**<br>
编写函数，输入两个整数，判断一个数是不是另一个数的倍数。并编写主函数输入3组数据进行测试。

<br>**Sample Input：**<br>
```
12 4
5 45
1 34
```

<br>**Sample Output：**<br>
```
4 is not a multiple of 12
45 is a multiple of 5
34 is a multiple of 1
```

<br>

## 5-3 停车时间
**Description：**<br>
如果停车时间不超过3小时，停车场的最低收费标准是2元，如果停车时间超过3小时，超出的每小时加收0.5元（不足1小时，按1小时计算）。但是停车时间在24小时内的最高收费额是10元。假设没有1辆汽车的停车时间会超过24小时。<br>
请编写一个程序，为昨天来停车的3位顾客计算并打印他们的停车费。这个程序将请你输入每一位顾客的停车时间，然后会按照列表格式打印出结果，最后计算并打印出昨天的收费总额。要求程序将通过自定义函数CalculateCharges计算每位顾客的收费额。
>输出格式：
>```
>printf( "%5s%15s%15s\n", "Car", "Hours", "Charge" );
>printf( "%5d%15.1f%15.2f\n",......);
>```

<br>**Sample Input：**<br>
`13.1 5 8.7`

<br>**Sample Output：**<br>
```
  Car          Hours         Charge
    1           13.1           7.50
    2            5.0           3.00
    3            8.7           5.00
TOTAL           26.8          15.50
```

<br>

## 5-4 计算组合数
**Description：**<br>
编程计算组合数![relation](https://github.com/jckling/Learn-C/tree/master/Task/5/5-4.png)的值。
>要求：<br>
>1）对不满足`m >= k > 0`的情况，用户要重新输入<br>
>2）主函数功能简单，明了

<br>**Sample Input：**<br>
`7,5`
<br>**Sample Output：**<br>
`21.00`
<br>**Sample Input：**<br>
```
5,7
7,5
```
<br>**Sample Output：**<br>
`21.00`

<br>

## 5-5 求最小公倍数
**Description：**<br>
设计一个函数，计算两个正整数的最小公倍数，并编写主函数测试。

<br>**Sample Input：**<br>
`24,14`

<br>**Sample Output：**<br>
`168`

<br>

## 5-6 最大公约数-1
**Description：**<br>
设计一个函数MaxCommonFactor()，利用欧几里德算法（也称辗转相除法）计算两个正整数的最大公约数。
>**提示：**<br>
>辗转相除法：<br>
>例如 `MaxCommonFactor(22，8)—> MaxCommonFactor(8，22%8) —> MaxCommonFactor(6，8%6) —> MaxCommonFactor(2，6%2)`<br>
>由于`6 % 2 = 0`，2即为22与8的最大公约数

<br>**Sample Input：**<br>
`22,8`

<br>**Sample Output：**<br>
`2`

<br>

## 5-7 求e的x幂
**Description：**<br>
编写程序，求![relation](https://github.com/jckling/Learn-C/tree/master/Task/5/5-7.png)。<br>
阶乘和求幂均由自定义函数完成，即：<br>
(a)编写函数Fac，要求参数为一个非负整数，返回计算它的阶乘<br>
(b)编写函数Mypow，功能为求x的n次幂。即`x^n`<br>
(c)编写函数CalculateE，并调用Fac及Mypow函数估算出数学常量`e^x`的值<br>
>要求 ：<br>
>1）主函数中调用CalculateE函数，要求能够提示用户确定想要的精度（即累加求和的项数）<br>
>2）输出结果保留2位小数，例如，x = 3，求和项数为7时，e^x的值为19.41

<br>**Sample Input：**<br>
```
3
7
```
<br>**Sample Output：**<br>
`19.41`

<br>

## 5-8 求最大公约数-2
**Description：**<br>
设计函数MaxCommonFactor()，按照如下方法，计算两个正整数的最大公约数。
>例如:<br>
>`a = 22, b = 8; a > b`，则`a = 22 - 8 = 14;`<br>
>`a = 14, b = 8; a> b`，则`a = 14 - 8 = 6;`<br>
>`a = 6, b = 8; a < b`，则`b = 8 - 6 = 2;`<br>
>`a = 6, b = 2; a > b`，则`a = 6 - 2 = 4;`<br>
>`a = 4, b = 2; a > b`，则`a = 4 - 2 = 2;`<br>
>`a = 2, b = 2; a == b`， <br>
>a 即为a与b的公约数

<br>**Sample Input：**<br>
```
22
8
```

<br>**Sample Output：**<br>
`2`

<br>

## 5-9 哥德巴赫猜想
**Description：**<br>
写一个程序验证哥德巴赫猜想: 一个不小于6 的偶数可以表示为两个素数之和,如`6 = 3 + 3, 8 = 3 + 5, 10 = 3 + 7 ……`，在主函数中输入一个数，输出如下形式：`34=3+31`。

>要求：<br>
>1）要能够处理非法数据，如，输入的数小于6 ，或是大于6的奇数<br>
>2）编写函数单独完成判断素数以及验证哥德巴赫猜想的过程，主函数仅完成非法数据的判断以及相应函数的调用

<br>**Sample Input：**<br>
`78`
<br>**Sample Output：**<br>
```
78=5+73
78=7+71
78=11+67
78=17+61
78=19+59
78=31+47
78=37+41
```
<br>**Sample Input：**<br>
```
23
34
```
<br>**Sample Output：**<br>
```
34=3+31
34=5+29
34=11+23
34=17+17
```

<br>

## 5-10 可逆素数对
**Description：**<br>
编写程序，统计100~1000之间的所有可逆素数对的数量并输出。
>要求：判断素数、颠倒顺序的功能分别由自定义的函数实现<br>
>**提示：**<br>
>可逆素数对是指一个素数的各位数值顺序颠倒后得到的数仍为素数，如113与311即为一个可逆素数对

<br>**Sample Input：**<br>
`无`

<br>**Sample Output：**<br>
```
101,101
107,701
113,311
131,131
......
787,787
797,797
919,919
929,929
count=29
```