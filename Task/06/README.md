# 目录
* [6-1 捐款统计](#6-1-捐款统计)
* [6-2 乘法的递归](#6-2-乘法的递归)
* [6-3 回文素数](#6-3-回文素数)
* [6-4 健壮的乘法](#6-4-健壮的乘法)
* [6-5 递归求最大公约数](#6-5-递归求最大公约数)
* [6-6 完全数](#6-6-完全数)
* [6-7 统计字符及行数](#6-7-统计字符及行数)
* [6-8 输出两个数的所有公约数](#6-8-输出两个数的所有公约数)
* [6-9 古埃及分数](#6-9-古埃及分数)

<br>

## 6-1 捐款统计
**Description：**<br>
某机构举办了一个捐款活动来为慈善事业捐款。每笔捐款的一小部分会用做捐款机构的操作费，捐款的其余部分会存入慈善基金。我们所编写的程序要记录该机构所有募集款项的数量，并从每笔捐款中扣除17%作为操作费用，剩余的83%存入慈善基金。程序应能显示每笔捐款扣除了17%的操作费用后的金额，以及目前慈善基金中的总金额。输入的金额小于等于0时结束。
>要求：<br>
>1）合理划分函数<br>
>2）合理定义变量的存储类型

<br>**Sample Input：**<br>
```
300
5000
-3
```

<br>**Sample Output：**<br>
```
After expenses:$249.00
Total raised:$249.00
After expenses:$4150.00
Total raised:$4399.00
```

<br>

## 6-2 乘法的递归
**Description：**<br>
使用递归方法实现两个数相加。
>**提示：**<br>
>`a＊b = a + a * (b - 1)`

<br>**Sample Input：**<br>
`3,5`

<br>**Sample Output：**<br>
`15`

<br>

## 6-3 回文素数 
**Description：**<br>
编写程序，统计并打印出1000以内的所有回文素数。任意整数i，当从左向右的读法与从右向左的读法是相同且为素数时，则称该数为回文素数。例如：11,373,757等均为回文素数。输出数字以空格分隔。

<br>**Sample Input：**<br>
`无`

<br>**Sample Output：**<br>
```
11 101 131 ...... 919 929 
count=16
```

<br>

## 6-4 健壮的乘法
**Description：**<br>
用递归算法实现两个数相乘。要求可以处理乘数为负数的情况。

<br>**Sample Input：**<br>
`3,-5`
<br>**Sample Output：**<br>
`-15`
<br>**Sample Input：**<br>
`-5,5`
<br>**Sample Output：**<br>
`-25`

<br>

## 6-5 递归求最大公约数
**Description：**<br>
编写程序使用辗转相除法求最大公约数。
>要求：使用递归实现<br>
>**提示：**<br>
>辗转相除法：<br>
>例如 `MaxCommonFactor(22，8)—> MaxCommonFactor(8，22%8) —> MaxCommonFactor(6，8%6) —> MaxCommonFactor(2，6%2)`<br>
>由于`6 % 2 = 0`，2即为22与8的最大公约数

<br>**Sample Input：**<br>
`46,9`
<br>**Sample Output：**<br>
`1`
<br>**Sample Input：**<br>
`50,5`
<br>**Sample Output：**<br>
`5`

<br>

## 6-6 完全数
**Description：**<br>
如果一个整数（包括1）的全部因子加起来正好等于本身，那么它就被称为“完全数”。<br>
例如，6就是一个完全数，因为`6 = 1 + 2 + 3`，请编写一个能够判断输入的参数是否是完全数的函数。再用这个函数来编写一个程序统计并打印出1~1000之间所有的完全数。

<br>**Sample Input：**<br>
`无`

<br>**Sample Output：**<br>
```
6
......
count = 3
```

<br>

## 6-7 统计字符及行数
**Description：**<br>
编写程序，统计输入的字符中字符个数、单词数、行数以及不完整行数。输入的字符以‘|’作为结束。请阅读提示，并将程序补充完整。<br>
1）  字符总数是指不是空白字符的字符总数。空白字符包括空格（‘ ’），换行符（‘\n’），制表符（‘\t’）<br>
2）  为了统计行数，程序可以检查换行符<br>
3）  一个单词是指不包含空白字符的一系列字符。即”adv”,”4rt”都是单词。因此，若当前读入的字符不是空白字符，且不在某个单词中，即表示这是一个新的单词。用变量inword来表示当前字符是否在单词中。如果当前字符为空白字符，且inword值为1，说明当前单词读入结束，应将inword置为0，并准备接受下一个单词<br>
4）  如果结束符（’|’）出现在一行之中，则将它作为一个不完整的行统计，也就是该行有字符但是没有换行符。如果STOP之前所读入的最后一个字符不是换行符，就计为一个不完整的行<br>
>**提示：**<br>
>程序的前缀及后缀代码已给出，补充while循环体即可
>```
>前缀代码:
>
>#include<stdio.h>
>#define STOP '|'
>int main()
>{
>	char c;                        //  当前读入的字符
>	char prev;                   //前一个读入的字符
>	long n_chars = 0;       // 字符数
>	int n_lines = 0;           // 行数
>	int n_words = 0;         // 单词数
>	int p_lines = 0;           // 不完整的行数
>	int inword = 0;            // 如果当前读入的字符c在一个单词中，则inword等于1
>	//printf("Enter text to be analyzed( | to terminate):\n");
>	prev = '\n';                  // 用于识别完整的行
>	while ( ( c = getchar() )!= STOP)
>	{
>		//  补充程序，统计字符数、行数、单词数
>```
>```
>后缀代码: 
>	
>}
>	if( prev != '\n')
>		p_lines =1;
>	printf(" characters = %ld, words = %d, lines = %d, partial lines = %d\n",
>		n_chars,n_words, n_lines, p_lines);
>	return 0;
>}
>```

<br>**Sample Input：**<br>
```
This is
an
apple.
|
```
<br>**Sample Output：**<br>
` characters = 14, words = 4, lines = 3, partial lines = 0`
<br>**Sample Input：**<br>
```
This
is
an
app|
```
<br>**Sample Output：**<br>
` characters = 11, words = 4, lines = 3, partial lines = 1`

<br>

## 6-8 输出两个数的所有公约数
**Description：**<br>
编写函数int CommonFactors(int a, int b)，计算a和b的所有公约数。第一次调用，返回最大公约数。以后只要再使用相同参数调用，每次返回下一个小一些的公约数。无公约数时返回-1。
>**提示：**<br>
>使用static变量

<br>**Sample Input：**<br>
`28 32`

<br>**Sample Output：**<br>
```
Common factor 1 is 4
Common factor 2 is 2
Common factor 3 is 1
```

<br>

## 6-9 古埃及分数
**Description：**<br>
古埃及人所指的分数，其分子必等于1，例如：1/2、1/3、1/4。我们称这些分子等于1的分数为“埃及分数”。现输入一个真分数，请将该分数分解为埃及分数之和。
>如：`8 / 11 = 1 / 2 + 1 / 5 + 1 / 37 + 1 / 4070`<br>
>运行结果：
>```
>8/11
>1/2+1/5+1/37+1/4070
>```
>**提示：**<br>
>其实分法有多种，比如8/11还可以分为8/11=1/2+1/5+1/55+1/110<br>
>但是我们规定一下分解原则：给定一个分数，总有一个少于它而且最接近它的埃及分数，故先找出这个埃及分数<br>
>例如：<br>
>对于8/11，少于它而且最接近它的埃及分数是1/2。我们可以把8/11写成：
`8/11=1/2+5/22` 少于而最接近5/22的埃及分数是`1/5=1/2+1/5+3/110`少于而最接近3/110的埃及分数是`1/37=1/2+1/5+1/37+1/4070`<br>
>1/2的来历是`11/8+1=2`，这个2做分母，得到一个埃及分数1/2<br>
>然后`8/11-1/2=5/22`，现在要把5/22分解。`22/5+1=5`，得到埃及分数1/5<br>
>`5/22-1/5=3/110`。`110/3+1=37`，得到埃及分数1/37<br>
>`3/110-1/37=1/4070`，结果刚好是一个埃及分数，故分解到此为止<br>

<br>**Sample Input：**<br>
`8/11`

<br>**Sample Output：**<br>
`1/2+1/5+1/37+1/4070`